#pragma once
#include "hack.h"

#include <Windows.h>
#include <stdio.h>
#include <stdbool.h>

// WARNING! This was written for Windows and will not work under other operating systems without modification!
// This relies on a Windows Named Pipe for interprocess communication, and it assumes it is always run on Windows.
// Please modify this to add support for interprocess communication on other operating systems.

// NB. This class was initially created as boilerplate code generated by ChatGPT (OpenAI. (2023). ChatGPT (August 3rd 2023 version).) and then modified to make it fit for purpose.

#define PIPE_NAME "\\\\.\\pipe\\articulate_assistant_pipe_game"
#define BUFFER_SIZE 1024
#define MESSAGE_TYPE unsigned char

typedef struct {
    HANDLE pipeHandle;
    bool isConnected;
} NamedPipe;

static NamedPipe* instance = NULL;

// We use global variables here to pass data around Gnollhack to minimize modification of Gnollhack's existing code, for compatibility with future game updates.
static double speechTherapyGame_poly_level = 0;

bool first_failure = TRUE;

const char* motivational_failure_quotes[38] = {
    "Logon say, \"Every defeat is a necessary step towards mastery.\"",
	"Logon say, \"Don't rush. Use your patience with pride.\"",
	"Logon say, \"Failure is temporary. Your lessons and growth from it are permanent.\"",
	"Logon say, \"Never give up. Never surrender.\"",
	"Logon say, \"Again? Good.\"",
	"Logon say, \"Fill the unforgiving minute with sixty seconds' worth of distance run.\"",
	"Logon say, \"The expert has failed more times than the novice has even tried.\"",
	"Logon say, \"When you are persistent, victory is not 'if', but 'when'.\"",
	"Logon say, \"Your strongest power comes from within.\"",
	"Logon say, \"Words are even mightier than weapons.\"",
	"Logon say, \"Words alone have brought tyrants to their knees.\"",
	"Logon say, \"Speak, and the universe listens.\"",
	"Logon say, \"Fight with unwavering resolve.\"",
	"Logon say, \"The wise fear the person who has failed a thousand times, because it means a thousand times they have got back up and kept going.\"",
	"Logon say, \"The monsters fear your next move. Give them no rest\"."
	"Logon say, \"When you were born and spoke your first word, the universe trembled.\"",
	"Logon say, \"Don't respect the knight in shining armor. Armor that's shiny has never been tested.\"",
	"Logon say, \"A person who brags about never failing isn't pushing their limits.\"",
	"Logon say, \"Dare to do difficult things.\"",
	"Logon say, \"Fear is an invitation to the brave.\"",
	"Logon say, \"What you earn through challenge and victory, you wield better than someone who had it handed to them.\"",
	"Logon say, \"No matter who guides you, your victories are yours alone.\"",
	"Logon say, \"Language is a powerful tool nobody can take away from you.\"",
	"Logon say, \"It's not the size of your words that matters, it's what you do with them.\"",
	"Logon say, \"There are hundreds of thousands of words out there. Find the ones that work best for you.\"",
	"Logon say, \"Be the author of your own story.\"",
	"Logon say, \"You cannot know that something can't be done, only that you haven't done it yet.\"",
	"Logon say, \"You are capable of things, now, that you could only dream of when you were younger. Imagine what you will be capable of tomorrow.\"",
	"Logon say, \"Every great and powerful person stumbled countless times on their journey.\"",
	"Logon say, \"If you're trying and failing, you're doing infinitely better than people who aren't trying at all.\"",
	"Logon say, \"That you are here, now, means you have beaten every bad day you've ever had.\"",
	"Logon say, \"Don't try hard because someone else tells you to. Try hard for you.\"",
	"Logon say, \"Yesterday's history, and tomorrow's a mystery, but today is a gift. That's why they call it the present!\"",
	"Logon say, \"Ask, and you shall receive.\"",
	"Logon say, \"Be persistent, and you will win.\"",
	"Logon say, \"It's good to rest, but don't stop.\"",
	"Logon say, \"New-born animals learn their most vital survival skill first. Yours was to communicate.\"",
	"Logon say, \"I once knew a young lady named Washoe, who was determined to be heard.\"",
	"Logon say, \"Taking on a hard challenge shows the strength of your will\"."
};

const char* motivational_failure_quotes_deaf[5] = {
    /* You see */ "Logon look at you with anticipation.",
    "Logon grin at you.",
    "Logon wink at you with a smile.",
    "Logon give you a thumbs up.",
    "Logon nod, with a smile."
};


// Prints to the screen the next motivational quote that encourages persistence through failure.
void speechTherapyGame_display_motivational_quote()
{
    if (first_failure)
    {
        pline_ex1(ATR_NONE, CLR_MSG_FAIL, "You tried well, but unfortunately that wasn't right.");
        pline_ex1(ATR_NONE, CLR_MSG_POSITIVE, "There is no penalty for getting it wrong. Try again!");
        first_failure = FALSE;
    } else
    {
        if (Deaf)
        {
            You_see(motivational_failure_quotes_deaf[u.speechTherapyGame_motivational_quote_deaf_index % sizeof(motivational_failure_quotes_deaf)]);
            u.speechTherapyGame_motivational_quote_deaf_index++;
        }
        else
        {
            You_hear(motivational_failure_quotes[u.speechTherapyGame_motivational_quote_index % sizeof(motivational_failure_quotes)]);
            u.speechTherapyGame_motivational_quote_index++;
        }
    }
}


void speechTherapyGame_minimizeGame()
{
    // This is redundant, because we can force AAA to the foreground when we want to.
    // ShowWindow(hWnd, SW_MINIMIZE);
}

NamedPipe* speechTherapyGame_getPipe() {
    // If the pipe struct has not been instantiated yet, create it.
    if (instance == NULL) {
        // You("see there is no pipe instance, so you create one.");
        instance = (NamedPipe*)malloc(sizeof(NamedPipe));
        instance->isConnected = false;
    }
    // If the pipe has not been connected yet, connect it.
    if (!instance->isConnected)
    {
        // You("see the pipe is not connected, so you try to connect to it.");
        instance->pipeHandle = CreateFile(
            PIPE_NAME,
            GENERIC_READ | GENERIC_WRITE,
            0,
            NULL,
            OPEN_EXISTING,
            0,
            NULL
        );
        auto error = GetLastError();

        if (instance->pipeHandle == INVALID_HANDLE_VALUE) {
            instance->isConnected = false;
            You("fail to connect to the pipe! (%d)", error);
            return NULL;
        } else
        {
            instance->isConnected = true;
            // You("successfully connect to the pipe.");
        }
    }
    return instance;
}

bool speechTherapyGame_sendString(const char* message) {
    if (speechTherapyGame_getPipe() != NULL)
    {
        // You("try to write to the pipe...");
        DWORD bytesWritten;
        bool result = WriteFile(
            speechTherapyGame_getPipe()->pipeHandle,
            message,
            strlen(message) + 1,
            &bytesWritten,
            NULL
        );
        auto error = GetLastError();
        if (result == true)
        {
            // You("successfully write to the pipe.");
        }
        else
        {
            You("fail to write to the pipe! (%d)", error);
        }
        return result;
    }
    return false;
}

bool speechTherapyGame_receiveString(char* buffer, DWORD bufferSize) {
    if (speechTherapyGame_getPipe() != NULL)
    {
        // You("try to read from the pipe...");
        DWORD bytesRead;
        BOOL result = ReadFile(
            speechTherapyGame_getPipe()->pipeHandle,
            buffer,
            bufferSize,
            &bytesRead,
            NULL
        );
        auto error = GetLastError();
        if (result == true)
        {
            // You("successfully read from the pipe.");
        }
        else
        {
            You("fail to read from the pipe! (%d)", error);
        }
        return result;
    }
    return false;
}

bool speechTherapyGame_sendByte(const MESSAGE_TYPE byte) {
    if (speechTherapyGame_getPipe() != NULL)
    {
        //You("try to write to the pipe...");
        DWORD bytesWritten;
        bool result = WriteFile(
            speechTherapyGame_getPipe()->pipeHandle,
            byte,
            2,
            &bytesWritten,
            NULL
        );
        auto error = GetLastError();
        if (result == true)
        {
            //You("successfully write to the pipe.");
        }
        else
        {
            You("fail to write to the pipe! (%d)",error);
        }
        return result;
    }
    return false;
}

bool speechTherapyGame_receiveByte(MESSAGE_TYPE* byte) {
    if (speechTherapyGame_getPipe() != NULL)
    {
        //You("try to read from the pipe...");
        DWORD bytesRead;
        BOOL result = ReadFile(
            speechTherapyGame_getPipe()->pipeHandle,
            byte,
            sizeof(MESSAGE_TYPE) + 1,
            &bytesRead,
            NULL
        );
        auto error = GetLastError();
        if (result == true)
        {
            //You("successfully read from the pipe.");
        }
        else
        {
            You("fail to read from the pipe! (%d)", error);
        }
        return result;
    }
    return false;
}

void speechTherapyGame_closePipe() {
    // You("try to close the pipe...");
    if (instance != NULL) {
        if (instance->isConnected) {
            speechTherapyGame_sendString("C"); // This is the shutdown signal we send to AAA to declare we are closing on this end.
            CloseHandle(instance->pipeHandle);
            instance->isConnected = FALSE;
        }
        free(instance);
        instance = NULL;
        // You("successfully close the pipe.");
    } else
    {
        You("find that the pipe is already closed! Why?");
    }
}

// The argument is written to with the actual difficulty of the challenge served to the player by AAA.
int speechTherapyGame_challengePlayer(int* difficulty) {

    if ((*difficulty < 0) || (*difficulty > 100))
    {
        impossible("A speech challenge was requested with an out-of-range difficulty!"); // Throw an exception in the Gnollhack style.
        return -1;
    }

    speechTherapyGame_minimizeGame();

	// Because C needs strings to have memory allocation for them specified at compile time, we are assuming that there will be 4 characters needed for this string: an initial one-character prefix followed by up to 3 characters for the number.
    char challenge_difficulty_as_string[BUFFER_SIZE];
    // Convert the integer to a string, prefixed with the letter 'A' which AAA will interpret as a request to serve the player a speech challenge.
    int number_of_characters_in_string = sprintf(challenge_difficulty_as_string, "A%d", *difficulty);

    // You can send any of the following messages to AAA:
    // A70  - Challenge the player with difficulty 70%. You can replace 70 with any number from 0 to 100.
    // T  - Send me a test response.
    // C  - Close your pipe handler.
    if (speechTherapyGame_sendString(challenge_difficulty_as_string)) {
        You("request a response from AAA.");

        unsigned char message[BUFFER_SIZE];

        if (speechTherapyGame_receiveByte(message)) {
            You("hear AAA reply: %d", message[0]);
            int challenge_result = message[0]; // The first byte of the incoming message from AAA is the score: an int in the range 0..100.
            int actual_difficulty = message[1]; // The second byte is the actual difficulty of the challenge served to the player.
            *difficulty = actual_difficulty; // We set the difficulty passed in as argument to the actual difficulty of the challenge served to the player.
            return challenge_result;
        }
        else {
            You("fail to receive a response from AAA.");
            return -1;
        }
    }
    else {
        You("fail to send a message on the pipe.");
        return -1;
    }

}


//int main() {
//    NamedPipe* pipe = speechTherapyGame_getPipe();
//
//    if (speechTherapyGame_sendString("Hello, named pipe!")) {
//        printf("Message sent successfully.\n");
//
//        char buffer[BUFFER_SIZE];
//        if (speechTherapyGame_receiveString(buffer, BUFFER_SIZE)) {
//            printf("Received: %s\n", buffer);
//        }
//        else {
//            printf("Failed to receive.\n");
//        }
//    }
//    else {
//        printf("Failed to send.\n");
//    }
//
//    speechTherapyGame_closePipe();
//
//    return 0;
//}



/*

#define PIPE_NAME "\\\\.\\pipe\\articulate_assistant_pipe_game"

// This class is a singleton. I chose this because I want the pipe handler to manage its own lifetime and ensure only a single instance of itself can exist.

typedef struct {
    HANDLE pipeHandle; // The object that maintains the Windows Named Pipe connection.
    bool connected; // Has a connection been established to another process using the pipe?
} NamedPipeSingleton;

// Only a single instance of the pipe should exist.
static NamedPipeSingleton instance = { INVALID_HANDLE_VALUE, false };

NamedPipeSingleton* speechTherapyGame_get_pipe() {
    return &instance;
}

bool speechTherapyGame_connect_to_pipe() {
    if (instance.connected)
    {
        return true;
    } else {
        instance.pipeHandle = CreateFileA(
            PIPE_NAME,
            GENERIC_READ | GENERIC_WRITE,
            0,
            NULL,
            OPEN_EXISTING,
            0,
            NULL
        );

        if (instance.pipeHandle == INVALID_HANDLE_VALUE) {
            You("try and fail to connect to the pipe.");
            return false;
        }

        instance.connected = true;
        return true;
    }
}

void NamedPipeSingleton_sendData(const char* data) {
    if (!instance.connected) {
        speechTherapyGame_connect_to_pipe();
    }

    DWORD bytesWritten;
    WriteFile(instance.pipeHandle, data, (DWORD)strlen(data), &bytesWritten, NULL);
}

void NamedPipeSingleton_disconnect() {
    if (instance.connected) {
        CloseHandle(instance.pipeHandle);
        instance.connected = false;
    }
}

//int main() {
//    NamedPipeSingleton* pipeSingleton = NamedPipeSingleton_getInstance();
//
//    if (NamedPipeSingleton_connect(pipeSingleton)) {
//        NamedPipeSingleton_sendData(pipeSingleton, "Hello, named pipe!");
//        NamedPipeSingleton_disconnect(pipeSingleton);
//    }
//
//    return 0;
//}


*/